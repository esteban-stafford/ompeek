
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Burst Visualiser</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:4px}
    .controls{display:flex;gap:12px;align-items:center;margin-bottom:8px;flex-wrap:wrap}
    #plot{width:100%;height:600px}
    .small{font-size:12px;color:#666}
    .row{display:flex;gap:8px;align-items:center}
    input[type=file]{display:none}
    .btn{padding:6px 10px;border-radius:6px;border:1px solid #bbb;background:#f6f6f6;cursor:pointer}
    .omp-header { display: flex; align-items: center; justify-content: space-between; gap: 1rem; }
    .logo-wrap h3 { margin: 4px; }
    .controls { display: grid; grid-template-columns: 1fr; grid-auto-rows: auto; gap: 0.5rem; align-items: center; }
    @media (max-width: 560px) { .omp-header { flex-direction: column; align-items: flex-start; gap: 0.75rem; } .controls { width: 100%; } }
  </style>
</head>
<body>
  <header class="omp-header">
    <div class="logo-wrap">
      <h3 class="brand"><img src="data:image/png;base64,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" alt="OMPeek"></h3>
    </div>

    <div class="controls" role="group" aria-label="OMPeek controls">
      <div class="row units-row">
        <label for="units">Units</label>
        <select id="units" name="units">
          <option value="0.000001">s</option>
          <option value="0.001">ms</option>
          <option value="1">µs</option>
        </select>
      </div>

      <div class="row color-row">
        <span class="row-label">Color by</span>
        <label><input type="radio" name="colorby" value="type" checked> type</label>
        <label><input type="radio" name="colorby" value="codeptr"> codeptr</label>
        <label><input type="radio" name="colorby" value="user"> user</label>
      </div>
    </div>
  </header>

  <div id="plot"></div>

  <div class="small">Hover lines for details. Crosshair at burst start. X axis scaled by selected units.</div>

  <script>
  const TYPE_NAMES = {
    0: 'serial',
    1: 'for',
    2: 'section',
    3: 'single',
    4: 'single_other',
    5: 'task',
    6: 'critical',
    7: 'wait',
    8: 'unknown'
  };

  function parseContent(txt){
    const lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(l=>l && !l.startsWith('#'));
    const bursts = [];
    for(const line of lines){
      const parts = line.split(':');
      if(parts.length < 7) continue;
      const thread = parts[0];
      const start = Number(parts[1]);
      const end = Number(parts[2]);
      const type = parts[3];
      const codeptr = parts[4];
      const user_id = Number(parts[5]);
      const user_level = Number(parts[6]);
      if(Number.isFinite(start) && Number.isFinite(end)){
        bursts.push({thread, start, end, type, codeptr, user_id, user_level});
      }
    }
    return bursts;
  }

  function unique(arr){ return Array.from(new Set(arr)); }

  const PALETTE = [
    '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'
  ];

  function buildColorMap(keys){
    const map = {};
    keys.forEach((k,i)=> map[k] = PALETTE[i % PALETTE.length]);
    return map;
  }

   /* function userColor(uid, lvl) {
      const hue = (uid * 137) % 360; // pseudo-random hue spacing
      const light = (lvl - user_level_min) / (user_level_max - user_level_min);
      return `hsl(${hue}, 100%, ${50+50*(light)}%)`; // darker for low level
    } */
  function render(bursts, unitsFactor, colorBy) {
    if (!bursts || bursts.length === 0) {
      Plotly.purge('plot');
      return;
    }

    const threads = [...new Set(bursts.map(b => b.thread))].sort((a, b) => Number(a) - Number(b));
    const yMap = {};
    threads.forEach((t, i) => (yMap[t] = i + 1));

    function userColor(uid, lvl) {
      const hue = (uid * 137) % 360;
      const light = Math.max(0, Math.min(lvl, 1));
      const lightPct = 20 + 80 * light; // 0→dark,1→bright
      return `hsl(${hue},100%,${lightPct / 2}%)`;
    }

    const traces = [];

    const crossX = bursts.map(b => b.start * unitsFactor);
    const crossY = bursts.map(b => yMap[b.thread]);
    traces.push({
      x: crossX,
      y: crossY,
      mode: 'markers',
      marker: { symbol: 'cross-thin-open', size: 8, color: '#000' },
      hoverinfo: 'none',
      showlegend: false
    });

    if (colorBy === 'user') {
      // find range of user_level in current data
      const user_level_min = Math.min(...bursts.map(b => b.user_level));
      const user_level_max = Math.max(...bursts.map(b => b.user_level));

      function userColor(uid, lvl) {
        const hue = (uid * 137) % 360;
        // normalise to [0,1]
        const light = (lvl - user_level_min) / (user_level_max - user_level_min || 1);
        const lightPct = 100 - 55 * Math.max(0, Math.min(light, 1));
        return `hsl(${hue}, 100%, ${lightPct}%)`;
      }

      // one trace per burst so each uses its own brightness
      for (const b of bursts) {
        const x = [b.start * unitsFactor, b.end * unitsFactor];
        const y = [yMap[b.thread], yMap[b.thread]];
        const typeWord = TYPE_NAMES[b.type] || b.type;
        const unitLabel =
          unitsFactor === 1 ? 'us' : unitsFactor === 0.001 ? 'ms' : 's';
        const txt = `thread: ${b.thread}<br>
                     start: ${(b.start * unitsFactor).toFixed(3)} ${unitLabel}<br>
                     end: ${(b.end * unitsFactor).toFixed(3)} ${unitLabel}<br>
                     duration: ${((b.end - b.start) * unitsFactor).toFixed(3)} ${unitLabel}<br>
                     type: ${typeWord}<br>
                     codeptr: ${b.codeptr}<br>
                     user_id: ${b.user_id}<br>
                     user_level: ${b.user_level}`;
        traces.push({
          x, y,
          mode: 'lines',
          line: { width: 6, color: userColor(b.user_id, b.user_level) },
          name: `user_${b.user_id}`,
          hoverinfo: 'text',
          hoverlabel: { align: 'left' },
          text: [txt],
          showlegend: false
        });
      }
    } else {
      // original grouping by type or codeptr
      const groups = {};
      for (const b of bursts) {
        const key = colorBy === 'type' ? b.type : b.codeptr;
        if (!groups[key]) groups[key] = [];
        groups[key].push(b);
      }

      const cmap = buildColorMap(Object.keys(groups));
      for (const key of Object.keys(groups)) {
        const segsX = [], segsY = [], hoverForPoints = [];
        for (const b of groups[key]) {
          segsX.push(b.start * unitsFactor, b.end * unitsFactor, null);
          segsY.push(yMap[b.thread], yMap[b.thread], null);
          const typeWord = TYPE_NAMES[b.type] || b.type;
          const unitLabel =
            unitsFactor === 1 ? 'us' : unitsFactor === 0.001 ? 'ms' : 's';
          const t = `thread: ${b.thread}<br>start: ${(b.start * unitsFactor).toFixed(3)} ${unitLabel}<br>end: ${(b.end * unitsFactor).toFixed(3)} ${unitLabel}<br>duration: ${((b.end - b.start) * unitsFactor).toFixed(3)} ${unitLabel}<br>type: ${typeWord}<br>codeptr: ${b.codeptr}`;
          hoverForPoints.push(t, t, '');
        }
        traces.push({
          x: segsX,
          y: segsY,
          mode: 'lines',
          line: { width: 6, color: cmap[key] },
          name: colorBy === 'type' ? TYPE_NAMES[key] || key : key,
          hoverinfo: 'text',
          hoverlabel: { align: 'left' },
          text: hoverForPoints,
          showlegend: true
        });
      }
    }

    const layout = {
      title: 'Bursts',
      xaxis: {
        title:
          'Time (' +
          (unitsFactor === 1 ? 'us' : unitsFactor === 0.001 ? 'ms' : 's') +
          ')'
      },
      yaxis: {
        tickmode: 'array',
        tickvals: threads.map(t => yMap[t]),
        ticktext: threads,
        autorange: 'reversed'
      },
      legend: {
        orientation: 'h',
        yanchor: 'top',
        y: -0.2,
        xanchor: 'center',
        x: 0.5
      },
      hovermode: 'closest',
      margin: { l: 80, r: 30, t: 40, b: 80 }
    };

    Plotly.newPlot('plot', traces, layout, { responsive: true });
  }

  const unitsSel = document.getElementById('units');
  let currentBursts = [];

  function updatePlot(){
    render(currentBursts, Number(unitsSel.value), document.querySelector('input[name=colorby]:checked').value);
  }

  unitsSel.addEventListener('change', updatePlot);
  document.querySelectorAll('input[name=colorby]').forEach(r=>r.addEventListener('change', updatePlot));
  document.addEventListener('DOMContentLoaded', function(){
    const embedded = document.getElementById('embedded-events');
    if (embedded) {
      const txt = embedded.textContent.trim();
      currentBursts = parseContent(txt);
      updatePlot();
    }
  });
  </script>
<!-- EVENT_DATA_PLACEHOLDER --> 
</body>
</html>
