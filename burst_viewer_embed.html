
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Burst Visualiser</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:4px}
    .controls{display:flex;gap:12px;align-items:center;margin-bottom:8px;flex-wrap:wrap}
    #plot{width:100%;height:600px}
    .small{font-size:12px;color:#666}
    .row{display:flex;gap:8px;align-items:center}
    input[type=file]{display:none}
    .btn{padding:6px 10px;border-radius:6px;border:1px solid #bbb;background:#f6f6f6;cursor:pointer}
    .omp-header { display: flex; align-items: center; justify-content: space-between; gap: 1rem; }
    .logo-wrap h3 { margin: 4px; }
    .controls { display: grid; grid-template-columns: 1fr; grid-auto-rows: auto; gap: 0.5rem; align-items: center; }
    @media (max-width: 560px) { .omp-header { flex-direction: column; align-items: flex-start; gap: 0.75rem; } .controls { width: 100%; } }
  </style>
</head>
<body>
  <header class="omp-header">
    <div class="logo-wrap">
      <h3 class="brand"><img src="ompeek.png" alt="OMPeek"></h3>
    </div>

    <div class="controls" role="group" aria-label="OMPeek controls">
      <div class="row units-row">
        <label for="units">Units</label>
        <select id="units" name="units">
          <option value="0.000001">s</option>
          <option value="0.001">ms</option>
          <option value="1">µs</option>
        </select>
      </div>

      <div class="row color-row">
        <span class="row-label">Color by</span>
        <label><input type="radio" name="colorby" value="type" checked> type</label>
        <label><input type="radio" name="colorby" value="codeptr"> codeptr</label>
        <label><input type="radio" name="colorby" value="user"> user</label>
      </div>
    </div>
  </header>

  <div id="plot"></div>

  <div class="row" id="stats-row" style="gap:12px;flex-wrap:wrap;margin-top:8px">
    <label>Serial time</label>
    <input id="serialTime" type="number" step="any" style="width:120px">

    <select id="serialUnits">
      <option value="0.000001">s</option>
      <option value="0.001">ms</option>
      <option value="1">µs</option>
    </select>
  </div>
  <div class="row" id="stats-row" style="gap:12px;flex-wrap:wrap;margin-top:8px">
    <span>Speedup: <b id="speedup">–</b></span>
    <span>Global efficiency: <b id="geff">–</b></span>
    <span>Computation efficiency: <b id="ceff">–</b></span>
    <span>Load balance: <b id="lbal">–</b></span>
  </div>

  <script>
  const TYPE_NAMES = {
    0: 'serial',
    1: 'for',
    2: 'section',
    3: 'single',
    4: 'single_other',
    5: 'task',
    6: 'critical',
    7: 'wait',
    8: 'unknown'
  };

  function parseContent(txt){
    const lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(l=>l && !l.startsWith('#'));
    const bursts = [];
    for(const line of lines){
      const parts = line.split(':');
      if(parts.length < 7) continue;
      const thread = parts[0];
      const start = Number(parts[1]);
      const end = Number(parts[2]);
      const type = parts[3];
      const codeptr = parts[4];
      const user_id = Number(parts[5]);
      const user_level = Number(parts[6]);
      if(Number.isFinite(start) && Number.isFinite(end)){
        bursts.push({thread, start, end, type, codeptr, user_id, user_level});
      }
    }
    return bursts;
  }

  function unique(arr){ return Array.from(new Set(arr)); }

  const PALETTE = [
    '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'
  ];

  function buildColorMap(keys){
    const map = {};
    keys.forEach((k,i)=> map[k] = PALETTE[i % PALETTE.length]);
    return map;
  }

   /* function userColor(uid, lvl) {
      const hue = (uid * 137) % 360; // pseudo-random hue spacing
      const light = (lvl - user_level_min) / (user_level_max - user_level_min);
      return `hsl(${hue}, 100%, ${50+50*(light)}%)`; // darker for low level
    } */
  function render(bursts, unitsFactor, colorBy) {
    if (!bursts || bursts.length === 0) {
      Plotly.purge('plot');
      return;
    }

    const threads = [...new Set(bursts.map(b => b.thread))].sort((a, b) => Number(a) - Number(b));
    const yMap = {};
    threads.forEach((t, i) => (yMap[t] = i + 1));

    function userColor(uid, lvl) {
      const hue = (uid * 137) % 360;
      const light = Math.max(0, Math.min(lvl, 1));
      const lightPct = 20 + 80 * light; // 0→dark,1→bright
      return `hsl(${hue},100%,${lightPct / 2}%)`;
    }

    const traces = [];

    const crossX = bursts.map(b => b.start * unitsFactor);
    const crossY = bursts.map(b => yMap[b.thread]);
    traces.push({
      x: crossX,
      y: crossY,
      mode: 'markers',
      marker: { symbol: 'cross-thin-open', size: 8, color: '#000' },
      hoverinfo: 'none',
      showlegend: false
    });

    if (colorBy === 'user') {
      // find range of user_level in current data
      const user_level_min = Math.min(...bursts.map(b => b.user_level));
      const user_level_max = Math.max(...bursts.map(b => b.user_level));

      function userColor(uid, lvl) {
        const hue = (uid * 137) % 360;
        // normalise to [0,1]
        const light = (lvl - user_level_min) / (user_level_max - user_level_min || 1);
        const lightPct = 100 - 55 * Math.max(0, Math.min(light, 1));
        return `hsl(${hue}, 100%, ${lightPct}%)`;
      }

      // one trace per burst so each uses its own brightness
      for (const b of bursts) {
        const x = [b.start * unitsFactor, b.end * unitsFactor];
        const y = [yMap[b.thread], yMap[b.thread]];
        const typeWord = TYPE_NAMES[b.type] || b.type;
        const unitLabel =
          unitsFactor === 1 ? 'us' : unitsFactor === 0.001 ? 'ms' : 's';
        const txt = `thread: ${b.thread}<br>
                     start: ${(b.start * unitsFactor).toFixed(3)} ${unitLabel}<br>
                     end: ${(b.end * unitsFactor).toFixed(3)} ${unitLabel}<br>
                     duration: ${((b.end - b.start) * unitsFactor).toFixed(3)} ${unitLabel}<br>
                     type: ${typeWord}<br>
                     codeptr: ${b.codeptr}<br>
                     user_id: ${b.user_id}<br>
                     user_level: ${b.user_level}`;
        traces.push({
          x, y,
          mode: 'lines',
          line: { width: 20, color: userColor(b.user_id, b.user_level) },
          name: `user_${b.user_id}`,
          hoverinfo: 'text',
          hoverlabel: { align: 'left' },
          text: [txt],
          showlegend: false
        });
      }
    } else {
      // original grouping by type or codeptr
      const groups = {};
      for (const b of bursts) {
        const key = colorBy === 'type' ? b.type : b.codeptr;
        if (!groups[key]) groups[key] = [];
        groups[key].push(b);
      }

      const cmap = buildColorMap(Object.keys(groups));
      for (const key of Object.keys(groups)) {
        const segsX = [], segsY = [], hoverForPoints = [];
        for (const b of groups[key]) {
          segsX.push(b.start * unitsFactor, b.end * unitsFactor, null);
          segsY.push(yMap[b.thread], yMap[b.thread], null);
          const typeWord = TYPE_NAMES[b.type] || b.type;
          const unitLabel =
            unitsFactor === 1 ? 'us' : unitsFactor === 0.001 ? 'ms' : 's';
          const t = `thread: ${b.thread}<br>start: ${(b.start * unitsFactor).toFixed(3)} ${unitLabel}<br>end: ${(b.end * unitsFactor).toFixed(3)} ${unitLabel}<br>duration: ${((b.end - b.start) * unitsFactor).toFixed(3)} ${unitLabel}<br>type: ${typeWord}<br>codeptr: ${b.codeptr}`;
          hoverForPoints.push(t, t, '');
        }
        traces.push({
          x: segsX,
          y: segsY,
          mode: 'lines',
          line: { width: 20, color: cmap[key] },
          name: colorBy === 'type' ? TYPE_NAMES[key] || key : key,
          hoverinfo: 'text',
          hoverlabel: { align: 'left' },
          text: hoverForPoints,
          showlegend: true
        });
      }
    }

    const layout = {
      title: 'Bursts',
      xaxis: {
        title:
          'Time (' +
          (unitsFactor === 1 ? 'us' : unitsFactor === 0.001 ? 'ms' : 's') +
          ')'
      },
      yaxis: {
        tickmode: 'array',
        tickvals: threads.map(t => yMap[t]),
        ticktext: threads,
        autorange: 'reversed'
      },
      legend: {
        orientation: 'h',
        yanchor: 'top',
        y: -0.2,
        xanchor: 'center',
        x: 0.5
      },
      hovermode: 'closest',
      margin: { l: 80, r: 30, t: 40, b: 80 }
    };

    Plotly.newPlot('plot', traces, layout, { responsive: true });
    computeStats(b);
  }

  const unitsSel = document.getElementById('units');
  let currentBursts = [];

  function updatePlot(){
    render(currentBursts, Number(unitsSel.value), document.querySelector('input[name=colorby]:checked').value);
  }

  function computeStats(bursts){
    if (!bursts.length) return;

    const threads = [...new Set(bursts.map(b=>b.thread))];
    const T = threads.length;

    const perThread = {};
    let sumAll = 0;
    let maxEnd = 0;

    for (const b of bursts){
      const d = b.end - b.start;
      sumAll += d;
      maxEnd = Math.max(maxEnd, b.end);
      perThread[b.thread] = (perThread[b.thread] || 0) + d;
    }

    const serial =
      Number(document.getElementById('serialTime').value || 0) /
      Number(document.getElementById('serialUnits').value || 1);

    if (serial <= 0) return;

    const speedup = serial / maxEnd;
    const geff = speedup / T;
    const ceff = serial / sumAll;

    const sums = Object.values(perThread);
    const avg = sums.reduce((a,b)=>a+b,0) / sums.length;
    const lbal = avg / Math.max(...sums);

    speedupEl.textContent = speedup.toFixed(3);
    geffEl.textContent = geff.toFixed(3);
    ceffEl.textContent = ceff.toFixed(3);
    lbalEl.textContent = lbal.toFixed(3);
  }

  const speedupEl = document.getElementById('speedup');
  const geffEl = document.getElementById('geff');
  const ceffEl = document.getElementById('ceff');
  const lbalEl = document.getElementById('lbal');

  ['serialTime','serialUnits'].forEach(id =>
    document.getElementById(id).addEventListener('input', ()=>computeStats(currentBursts))
  );

  unitsSel.addEventListener('change', updatePlot);
  document.querySelectorAll('input[name=colorby]').forEach(r=>r.addEventListener('change', updatePlot));
  document.addEventListener('DOMContentLoaded', function(){
    const embedded = document.getElementById('embedded-events');
    if (embedded) {
      const txt = embedded.textContent.trim();
      currentBursts = parseContent(txt);
      updatePlot();
    }
  });
  </script>
<!-- EVENT_DATA_PLACEHOLDER --> 
</body>
</html>
